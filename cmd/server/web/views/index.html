<div class="container mx-auto p-4">
  <h1 class="text-4xl font-bold mb-4">MQ Watch</h1>

  <form id="queryForm" class="mb-4">
    <div class="flex space-x-4 mb-4">
      <div class="flex flex-col">
        <label for="startDate" class="mb-2">Start Date:</label>
        <input type="date" id="startDate" name="start_date" required class="border p-2 rounded">
      </div>

      <div class="flex flex-col">
        <label for="startTime" class="mb-2">Start Time:</label>
        <input type="time" id="startTime" name="start_time" required class="border p-2 rounded">
      </div>
    </div>

    <div class="flex space-x-4 mb-4">
      <div class="flex flex-col">
        <label for="endDate" class="mb-2">End Date:</label>
        <input type="date" id="endDate" name="end_date" required class="border p-2 rounded">
      </div>

      <div class="flex flex-col">
        <label for="endTime" class="mb-2">End Time:</label>
        <input type="time" id="endTime" name="end_time" required class="border p-2 rounded">
      </div>
    </div>

    <button type="button" id="queryBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Query Messages</button>
  </form>

  <div id="results" class="mb-4">
    <p class="text-xl font-semibold"><strong>Total Messages:</strong> <span id="totalMessages"></span></p>
  </div>

  <div class="mb-4">
    <button id="toggleTenants" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded mb-4">Toggle All Tenants</button>
    <canvas id="lineChart"></canvas>
  </div>

  <div id="tableContainer" class="overflow-x-auto">
    <table id="dataTable" class="min-w-full bg-white border border-gray-300">
      <thead>
      <tr class="bg-gray-200 text-gray-600 uppercase text-sm leading-normal">
        <th class="py-3 px-6 text-left">Tenant</th>
        <th class="py-3 px-6 text-left">Total Messages</th>
      </tr>
      </thead>
      <tbody class="text-gray-600 text-sm font-light">
      <!-- Data rows will be populated dynamically -->
      </tbody>
    </table>
  </div>
</div>

<script>
  let myChart;
  document.addEventListener("DOMContentLoaded", function () {
    const today = new Date();
    const lastWeek = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    document.getElementById("endDate").value = today.toISOString().substr(0, 10);
    document.getElementById("endTime").value = today.toTimeString().substr(0, 5);
    document.getElementById("startDate").value = lastWeek.toISOString().substr(0, 10);
    document.getElementById("startTime").value = "00:00";

    const queryBtn = document.getElementById("queryBtn");
    const resultsDiv = document.getElementById("results");
    const totalMessagesSpan = document.getElementById("totalMessages");
    const tenantMessagesSpan = document.getElementById("tenantMessages");
    const messagesPerTenant = document.getElementById("messagesPerTenant");

    queryBtn.addEventListener("click", function() {
      const startDate = document.getElementById("startDate").value;
      const startTime = document.getElementById("startTime").value;
      const endDate = document.getElementById("endDate").value;
      const endTime = document.getElementById("endTime").value;

      // Construct the URL for querying
      let startDateTime = `${startDate}T${startTime}:00Z`;
      let endDateTime = `${endDate}T${endTime}:00Z`;
      let queryURL = `/api/messages?start_datetime=${startDateTime}&end_datetime=${endDateTime}`;

      fetch(queryURL)
        .then(response => {
          if (!response.ok) {
            throw new Error(response.statusText);
          }
          return response.json();
        })
        .then(data => {
          totalMessagesSpan.textContent = data.total_messages;
          // Populate the chart (assuming you have a canvas with id 'lineChart' for this to work)
          let dates = Object.keys(data.daily_data);
          let filledDailyData = fillDateGaps(dates, data.daily_data);
          dates = Object.keys(filledDailyData);  // Update dates to include all in range
          let tenants = [...new Set([].concat(...dates.map(date => Object.keys(data.daily_data[date]))))];
          let datasets = tenants.map(tenant => {
            let dataForTenant = dates.map(date => data.daily_data[date][tenant] || 0);
            return {
              label: tenant,
              data: dataForTenant,
              fill: false,
              borderColor: randomColor(),
              tension: 0.1
            };
          });
          var ctx = document.getElementById('lineChart').getContext('2d');

          let chartOptions = {
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  fontColor: 'white',
                  callback: function(value) {
                    if (Math.floor(value) === value) {
                      return value;
                    }
                  },
                  stepSize: 1
                },
                grid: {
                  borderColor: 'rgba(255, 255, 255, 0.1)'
                }
              }
            },
            legend: {
              labels: {
                fontColor: 'white' // sets legend label color
              }
            }
          };
          if (myChart) {
            myChart.destroy(); // Destroy the existing chart
          }
          myChart = new Chart(ctx, {
            type: 'line',
            options: chartOptions,
            data: {
              labels: dates,
              datasets: datasets
            }
          });

          // Calculate totals per tenant for the selected period
          let tenantTotals = {};

          dates.forEach(date => {
            tenants.forEach(tenant => {
              if (!tenantTotals[tenant]) {
                tenantTotals[tenant] = 0;
              }
              tenantTotals[tenant] += data.daily_data[date][tenant] || 0;
            });
          });

          // Populate the table with tenant totals
          const dataTable = document.getElementById("dataTable");
          const tbody = dataTable.querySelector("tbody");
          tbody.innerHTML = ''; // Clear existing rows

          for (let tenant in tenantTotals) {
            const tr = document.createElement("tr");

            const tdTenant = document.createElement("td");
            tdTenant.textContent = tenant;
            tr.appendChild(tdTenant);

            const tdTotal = document.createElement("td");
            tdTotal.textContent = tenantTotals[tenant];
            tr.appendChild(tdTotal);

            tbody.appendChild(tr);
          }

        })
        .catch(error => {
          console.error("Error fetching data:", error);
          resultsDiv.textContent = "Error fetching data.";
        });

      let allVisible = true;  // This flag tracks the state of tenant visibility.

      document.getElementById("toggleTenants").addEventListener("click", function() {
        if (myChart) {
          myChart.data.datasets.forEach(dataset => {
            dataset.hidden = allVisible;  // If all are visible, hide them and vice-versa.
          });
          allVisible = !allVisible;  // Toggle the visibility flag.
          myChart.update();  // Update the chart to reflect the changes.
        }
      });
    });

    function randomColor() {
      let r = Math.floor(Math.random() * 255);
      let g = Math.floor(Math.random() * 255);
      let b = Math.floor(Math.random() * 255);
      return `rgba(${r}, ${g}, ${b}, 1)`;
    }

    function fillDateGaps(dates, daily_data) {
      let filledData = {...daily_data};
      let startDate = new Date(dates[0]);
      let endDate = new Date(dates[dates.length - 1]);

      for (let d = startDate; d <= endDate; d.setDate(d.getDate() + 1)) {
        let dateString = d.toISOString().split('T')[0];
        if (!filledData[dateString]) {
          filledData[dateString] = {};
        }
      }
      return filledData;
    }

  });
</script>

